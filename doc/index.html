<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>yao::home</title>
<script type="text/javascript" src="scripts.js">void=null;</script>
<link rel="stylesheet" href="styles.css" type="text/css">
</head>
<body>

<div id="left-column"><img src="images/kbkheaderleft.jpg"></div>
<div id="right-column"><img src="images/kbkheaderright.jpg"></div>

<div id="center">
  
 <div id="banner">yao::home</div>

<div id="links2">
  <a href="index.html">HOME</a> &nbsp; | &nbsp;
  <a href="installation.html">INSTALL</a> &nbsp; |  &nbsp; 
  <a href="manual.html">MANUAL</a> &nbsp;  | &nbsp; 
<!--   <a href="screenshots.html">SCREENSHOTS</a> &nbsp;  | &nbsp;  -->
  <a href="news.html">NEWS</a> 
  </div>



  <div id="container">
   <h2>Introduction</h2>
   
   These pages present information about <b>yao</b>, a Monte-Carlo simulation tool for Adaptive optics (AO) systems.
   <b>Yao</b> is open source released under the GPLv3. You are welcome
   to use it, expand it and even distribute it, but please link back
   to this page, as I am releasing updates semi-regularly. The last
   version of yao (big release, lots of new stuff) to date (July 2010)
   is <b>4.6.0</b>. Looks <a href="news.html">here</a> for the
   latest news.<a name="features" id="features"></a></p>
 
   <h2>Main features</h2>

   <a href="images/yao_mcao_gui.png"><img src="images/yao_mcao_gui.png" width="35%"  class="imglink" style="float:right;" /></a>
   <b>Yao</b> is a Monte-Carlo AO simulation tool. It uses a number of custom developed functions to simulate wavefront sensors (WFS), deformable mirrors (DM) and many other aspects of an AO loop.
   
   
   <h3>Highlights</h3>
   <ul class="spaced">

     <li><font class="highlight">Coded in <a href="http://yorick.sourceforge.net">yorick</a></font>, a open source scripting language similar to IDL or mathlab (powerful and free!). The core, CPU intensive routines are coded in C. Yorick and the YAO plugins are written in ANSI-C, which makes them portable on many platforms. YAO should run on any *nix platform, including Linux, Mac OsX, BSD, cygwin, etc... It may also work on windows, but I have never tried.</li>

     <li>
       <font class="highlight">Shack-Hartmann</font>,
       <font class="highlight">Curvature</font> and
       <font class="highlight">Modal</font> (Zernike) 
       <font class="highlight">WFS</font>,
       ON or OFF axis, are supported. It is also possible
       to <font class="highlight">add your own
       WFS</font> <font class="new">NEW 4.5</font>.
     </li>
     <li>
       <font class="highlight">Stackarray</font> (piezostack), 
       <font class="highlight">curvature</font> (bimorph), 
       <font class="highlight">segmented</font> <font class="new">NEW 4.5</font>, (experimental), 
       <font class="highlight">modal</font> (zernike,
       disk-marmonic <font class="new">NEW 4.6</font> or
       KL) and 
       <font class="highlight">Tip-Tilt deformable mirrors</font> 
       are supported. The altitude of conjugation is adjustable. It is
       also possible  to <font class="highlight">add your own
       DM</font> <font class="new">NEW 4.5</font>.
     </li>
     <li><font class="highlight">Various reconstructors:
     least-square with truncation (SVD) and MMSE-like</font>. MMSE can use
     either full matrix or sparse methods (fast). Users can hook into
     yao and use their own code to compute the
     reconstructor <font class="new">NEW 4.5.2</font></li>
     <li>An <font class="highlight">arbitrary number of WFSs and DMs</font> can be used, with the possibility of mixing types. It is therefore possible  to simulate single DM systems, as well as single non-zero conjugate, GLAO and MCAO systems.
     </li>
     <li>It supports <font class="highlight">Natural and Laser Guide Stars</font> (or a mix).
     </li>
     <li>It supports <font class="highlight">photon and read-out noise</font>.
     </li>
     <li>It uses a multi-layered atmospheric model, with geometrical propagation only.
     </li>
     <li>The loop execution has been <font class="highlight">optimized
       for speed</font>: the critical routines have been coded in
       C. Yorick is thus used as a convenient "glue" between lower
       levels optimized C calls. Overall, this is rather efficient: A
       simple 6x6 Shack-Hartmann system (geometrical model, no
       diffraction) runs at <font class="highlight">over a 1000
       iterations/seconds</font> on modern machines (about 250it/sec
       for a full diffractive SHWFS). That's including turbulent phase
       computation, wavefront sensing, reconstruction, calculation of
       the DM shape and PSF/performance estimation.  A 50x50
       Shack-Hartmann (full diffraction model) system runs at about 10
       iterations/s for an 8-m telescope. A 188 curvature system runs
       at over 40 iterations/s (see
       the <a href="news.html#breaking_the_1000itpersec_barrier">this
       entry</a> for more details). Medium-size AO systems for ELTs
       can also be simulated, but it takes more time and RAM (a 60x60
       SH on a 960 pixel pupil runs at about 1 iteration/s and takes
       up to 2GB of RAM at peak usage).<br>
       <b>Update</b>: yao 4.6.0 brings parallel computation!
       See <a href="news.html#Parallel_yao_released_with_improvements">this
       post</a> in the news. On modern hardware, it is now possible to
       simulate up to 200x200 SHWFS (1 iteration/s). A 64x64SHWFS runs
       at 23 iterations/s).
     </li>
     <li>Straightforward <font class="highlight">scriptability</font> to probe parameter space.
     </li>
     <li>An (optional) GTK <font class="highlight">GUI</font> provides a convenient interface. One can, e.g., change some of the system parameters <font class="highlight">while the loop is running</font>. This provides an educational approach to Adaptive Optics (newbies can play with the parameters and immediately sees how the system reacts) and can also provides a quick way to investigate the stability conditions for a newly designed system, before entering more serious Monte-carlo simulations. Note that because the GUI is GTK-based, it requires the gnome libraries. These come automatically in Linux and BSD, but are a bit more challenging to install on OsX (but possible with <a href="http://www.macports.org/">macport</a> or <a href="http://www.finkproject.org/">fink</a>). Note that the GUI is not essential to run YAO.
     </li>
   </ul>
   <h3>Other capabilities</h3>
   <ul class="spaced">
     <li>Arbitrary aperture shape (defined through a user plugin). Disk with central obstruction is the stock pupil, but examples are provided to create segmented or GMT like pupils.</li>
     <li>Partitioning of DMs and WFSs in independent subsystems (e.g. for separate control of TT in LGS systems)
     </li>
     <li>2 methods for Shack-Hartmann:
       <ol>
         <li>Simple gradient average, no noise, very fast: This allow to do tests of the noiseless performance of a system, for quick performance evaluation of system dimensioning
         </li>
         <li>Full propagation, with subaperture image
         formation. Includes adjustable subaperture and pixel size,
         photon and read-out noise, bias and flat field errors,
         thresholding, convolution by a gaussian kernel and image
         elongation in the case of LGS. Proper overlap between
         subapertures and possibility to put a field stop with
         adjustable shape, size and position <font class="new">NEW 4.5</font> .
         </li>
       </ol>
     </li>
     <li>Separately adjustable integration time for each sensor</li>
     <li>Adjustable frame delay (in integer unit of the quantum loop time)</li>
     <li>Anisoplanatism modes for MCAO</li>
     <li>Infinite impulse response, up to 10th
     order <font class="new">NEW 4.5</font></li>
     <li>Separate control laws for each DM</li>
     <li>DM hysteresis</li>
     <li>DM saturation</li>
     <li>Adjustable DM sensitivity (micron/volt) to hook to real systems</li>
     <li>Adjustable subaperture and actuator validation thresholds</li>
     <li>Adjustable multi-wavelength, multi-position performance estimate</li>
     <li>"Skip and reset" along the phase screens at adjustable interval, to reach statistically significant performance estimates faster</li>
     <li>Uplink tip-tilt correction for LGS</li>
     <li>Adjustable LGS elongation</li>
     <li>Rayleigh fratricide effect for multiple sodium beacon systems</li>
     <li>Extrapolated actuators</li>
     <li>Centroid gain optimization, using LGS dithering (only for LGS + Shack-Hartmann)</li>
     <li>Parametrizable vibration spectrum: white, 1/f, peaks with
     adjustable rms and width <font class="new">NEW 4.5</font>
     <li>Lots of internal variables are accessible from the outside of the program for debugging/implementation of new features</li>
   </ul>
   <h3>Comments and shorcomings</h3>
   <ul class="spaced">
     <li>Dependency on <font class="highlight">FFTW</font> for the
     fast FFT C implementation.</li>
     <li>Dependencies on the following yorick packages: yutils
     (general utilities, v&ge;1.3), imutil (image manipulation,
     v&ge;0.5), soy (sparse operations with yorick, v&ge;1.2) and svipc (v0.9)</li>
     <li>The set-up routines (aoinit) have not yet been optimized for speed, thus, in particular, inverting large matrices can take some time. This optimization may come in due time, if deemed necessary.</li>
     <li>
       <font class="highlight">There is no GUI to configure the systems</font>. The parfile has to be edited manually, which in my view is not a big deal and actually allows for more compact &amp; clever parfiles, as yorick loops can be used to set repetitive variables.
     </li>
     <li>Some work has been done with pyramid WFS but no has not been maintained and does not work in the current version
     </li>
     <li>Scintillation is not supported, as it has been shown by many studies to be negligible at NIR wavelengths.
     </li>
     <li>Command matrices are up to now computed as least-square estimates. Implementation of minimum-variance or MAP should come shortly.
     </li>
   </ul><a name="start" id="start"></a>
 
   <h2>Where to start?</h2>
   Browse this site. Have a look at the <a href="manual.html">manual</a>. If you like what you see, go to the <a href="installation.html">Installation</a> page and follow the instructions.
   <p>Once the package is installed, follow the manual instruction, and use the examples parameter files to create your own parfile to model your system.</p>
  </div>
</div>


<div id="footer">
<div id="footer-left"><img src="images/kbkfooterleft.jpg"></div>
<div id="footer-right"><img src="images/kbkfooterright.jpg"></div>  
<div id="footer-center"></div>
</div>

</body>
</html>
